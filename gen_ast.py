import sys
from datetime import datetime

class CodeAssembler:
    def __init__(ca) -> None:
        ca.defTabSize = 4
        ca.body = [] 
        ca.tabSize = 0

    def insert(ca, line: str = ''):
        line = (ca.tabSize * " ") + line + "\n"
        ca.body.append(line);

    def dedent(ca):
        if (ca.tabSize > 0):
            ca.tabSize -= ca.defTabSize

    def indent(ca):
        ca.tabSize += ca.defTabSize

    def indentInsertDedent(ca, line: str):
        ca.indent()
        ca.insert(line)
        ca.dedent()

    def __str__(ca) -> str:
        return ''.join(ca.body)

# add top comments and include statements
# aka boilerplate
def addTopOfFile(Cpp: CodeAssembler, baseClass: str):
    Cpp.insert("//") 
    Cpp.insert(f"// {baseClass}.h")
    Cpp.insert("// Croix")
    Cpp.insert("//")
    day = datetime.today().strftime('%Y-%m-%d')
    Cpp.insert(f"// Generated by Joshua Pepple on {day}.")
    Cpp.insert("//")
    Cpp.insert()
    Cpp.insert("#pragma once")
    Cpp.insert()

    Cpp.insert("#include <iostream>")
    Cpp.insert("#include <string>")
    Cpp.insert('#include "Token.h"')
    Cpp.insert()
    Cpp.insert("using namespace std;")

def defineVisitableGeneric(Cpp: CodeAssembler):
    Cpp.insert()
    Cpp.insert("// class to be inherited by abstract base class")
    Cpp.insert("// to allow the template defined types visit this class")
    visitorTag = "Visitor"
    Cpp.insert(f"template <typename {visitorTag}>")
    Cpp.insert("class Visitable {")
    Cpp.insert("public:")
    Cpp.indentInsertDedent(f"virtual void accept({visitorTag}*) = 0;")
    Cpp.insert("};")

def forwardDeclareClasses(Cpp: CodeAssembler, classes: list[str]):
    Cpp.insert()
    
    for cl in classes:
        Cpp.insert(f"class {cl};")

def defineExprVisitor(Cpp: CodeAssembler, classes: list[str], baseClass: str):
    Cpp.insert()
    Cpp.insert("// class to be inherited by classes that intend to visit")
    Cpp.insert("class ExprVisitor {")
    Cpp.insert("public:")
    
    for cl in classes:
        ln = f"virtual void visit{cl}{baseClass}({cl}*) = 0;"
        Cpp.indentInsertDedent(ln)
    Cpp.insert("};")

def defineBaseClass(Cpp: CodeAssembler, baseClass: str):
    Cpp.insert()
    Cpp.insert("// anything that is an ExprVisitor can visit this class")
    Cpp.insert(f"class {baseClass} : public Visitable<ExprVisitor> " + "{")
    Cpp.insert("};")

def defineAst(outDir: str, baseClass: str, types: list[str]):
    outPath = "./" + outDir + '/' + baseClass +'.h'
    # outPath = "./" + outDir + '/VisitorPattern.h'

    print("writing to", outPath)
    Cpp = CodeAssembler()

    addTopOfFile(Cpp, baseClass)    
    defineVisitableGeneric(Cpp)

    classes = [
        "Binary",
        "Unary", 
        "Grouping",
        "Boolean",
        "Number",
        "String"
    ]
    forwardDeclareClasses(Cpp, classes)

    defineExprVisitor(Cpp, classes, baseClass)

    defineBaseClass(Cpp, baseClass)
    
    for t in types:
        Cpp.insert()
        className = t.split(':')[0].strip()
        fields = t.split(':')[1].strip()
        defineType(Cpp, baseClass, className, fields)
    
    with open(outPath, 'w+') as astFile:
        astFile.write(str(Cpp))

def defineType(Cpp: CodeAssembler, baseClass: str, className: str, fieldList: str):
    # start of new class 
    Cpp.insert(f"class {className} : public {baseClass} " + "{")

    Cpp.insert("public:")
    # indent into definition of class
    Cpp.indent()
    # constructor
    Cpp.insert(f"{className}({fieldList}) " + "{")

    # constructor body
    fields = fieldList.split(', ')
    for f in fields:
        varName = f.split(" ")[1]
        Cpp.indentInsertDedent(f"this->{varName} = {varName};")

    Cpp.insert("}")

    Cpp.insert()
    Cpp.insert("void accept(ExprVisitor* ev) {")
    Cpp.indentInsertDedent(f"ev->visit{className}{baseClass}(this);")
    Cpp.insert("}")
    Cpp.dedent()

    Cpp.insert()
    for f in fields:
        Cpp.indentInsertDedent(f+';')
    Cpp.insert("};")
    Cpp.dedent()
    

argc = len(sys.argv)
if (argc != 2):
    print("usage: py gen_ast.py <output_dir>")
    exit(64) # exit with wrong usage error

dest = sys.argv[1]

types = [ 
    "Binary    :  Expr* left, Token op, Expr* right",
    "Unary     :  Token op, Expr* right",
    "Grouping  :  Expr* expr",
    "Boolean   :  bool value",
    "Number    :  double value",
    "String    :  string value",
    # "Henok     :  int age, string hairColor, string top, string bottom"
]

defineAst(dest, "Expr", types)
