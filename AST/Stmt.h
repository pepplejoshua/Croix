//
// Stmt.h
// Croix
//
// Generated by Joshua Pepple on 2021-12-08.
//

#pragma once

#include <iostream>
#include <string>
#include "Token.h"
#include "Expr.h"

using namespace std;

class Expression;
class Print;
class Var;

// class to be inherited by abstract base class
// to allow the template defined types visit this class
// it is visited by V1 and returns R1
// it is visited by V2 and returns R2
template < typename V1, typename R1 >
class VisitableStmt {
public:
    virtual R1 accept(V1) = 0;
};

// class to be inherited by classes that intend to visit
template < typename ReturnValue >
class StmtVisitor {
public:
    virtual ReturnValue visitExpressionStmt(Expression*) = 0;
    virtual ReturnValue visitPrintStmt(Print*) = 0;
    virtual ReturnValue visitVarStmt(Var*) = 0;
};

// anything that is an ExprVisitor can visit this class
class Stmt : public VisitableStmt < StmtVisitor < void > *, void > {
public:
    virtual char type() const = 0;
};

class Expression : public Stmt {
public:
    Expression(Expr* expr) {
        this->expr = expr;
    }
    
    void accept(StmtVisitor< void >* ev) {
        ev->visitExpressionStmt(this);
    }
    
    char type() const {
        return 'E';
    }

    Expr* expr;
};

class Print : public Stmt {
public:
    Print(Expr* expr) {
        this->expr = expr;
    }
    
    void accept(StmtVisitor< void >* ev) {
        ev->visitPrintStmt(this);
    }
    
    char type() const {
        return 'P';
    }

    Expr* expr;
};

class Var : public Stmt {
public:
    Var(Token name, Expr* initValue) {
        this->name = name;
        this->initValue = initValue;
    }
    
    void accept(StmtVisitor< void >* ev) {
        ev->visitVarStmt(this);
    }
    
    char type() const {
        return 'V';
    }

    Token name;
    Expr* initValue;
};
