//
// Stmt.h
// Croix
//
// Generated by Joshua Pepple on 2021-12-30.
//

#pragma once

#include <iostream>
#include <string>
#include "Token.h"
#include "Expr.h"
#include <vector>

using namespace std;

class Expression;
class Print;
class Var;
class Block;
class If;
class While;
class Function;
class Return;

// class to be inherited by abstract base class
// to allow the template defined types visit this class
// it is visited by V1 and returns R1
// it is visited by V2 and returns R2
template < typename V1, typename R1 >
class VisitableStmt {
public:
    virtual R1 accept(V1) = 0;
};

// class to be inherited by classes that intend to visit
template < typename ReturnValue >
class StmtVisitor {
public:
    virtual ReturnValue visitExpressionStmt(Expression*) = 0;
    virtual ReturnValue visitPrintStmt(Print*) = 0;
    virtual ReturnValue visitVarStmt(Var*) = 0;
    virtual ReturnValue visitBlockStmt(Block*) = 0;
    virtual ReturnValue visitIfStmt(If*) = 0;
    virtual ReturnValue visitWhileStmt(While*) = 0;
    virtual ReturnValue visitFunctionStmt(Function*) = 0;
    virtual ReturnValue visitReturnStmt(Return*) = 0;
};

// anything that is an ExprVisitor can visit this class
class Stmt : public VisitableStmt < StmtVisitor < void > *, void > {
public:
    virtual char type() const = 0;

    virtual ~Stmt() { }
};

class Expression : public Stmt {
public:
    Expression(Expr* expr) {
        this->expr = expr;
    }
    
    ~Expression() {
        delete this->expr;
    }
    
    void accept(StmtVisitor< void >* ev) {
        ev->visitExpressionStmt(this);
    }
    
    char type() const {
        return 'E';
    }

    Expr* expr;
};

class Print : public Stmt {
public:
    Print(Expr* expr) {
        this->expr = expr;
    }
    
    ~Print() {
        delete this->expr;
    }
    
    void accept(StmtVisitor< void >* ev) {
        ev->visitPrintStmt(this);
    }
    
    char type() const {
        return 'P';
    }

    Expr* expr;
};

class Var : public Stmt {
public:
    Var(Token name, Expr* initValue) {
        this->name = name;
        this->initValue = initValue;
    }
    
    ~Var() {
        delete this->initValue;
    }
    
    void accept(StmtVisitor< void >* ev) {
        ev->visitVarStmt(this);
    }
    
    char type() const {
        return 'V';
    }

    Token name;
    Expr* initValue;
};

class Block : public Stmt {
public:
    Block(vector < Stmt* > stmts) {
        this->stmts = stmts;
    }
    
    ~Block() {
        for(int i = 0; i < stmts.size(); ++i) {
            delete stmts[i];
        }
    }
    
    void accept(StmtVisitor< void >* ev) {
        ev->visitBlockStmt(this);
    }
    
    char type() const {
        return '{';
    }

    vector < Stmt* > stmts;
};

class If : public Stmt {
public:
    If(Expr* cond, Stmt* then, Stmt* else_) {
        this->cond = cond;
        this->then = then;
        this->else_ = else_;
    }
    
    ~If() {
        delete this->cond;
        delete this->then;
        delete this->else_;
    }
    
    void accept(StmtVisitor< void >* ev) {
        ev->visitIfStmt(this);
    }
    
    char type() const {
        return 'i';
    }

    Expr* cond;
    Stmt* then;
    Stmt* else_;
};

class While : public Stmt {
public:
    While(Expr* cond, Stmt* body) {
        this->cond = cond;
        this->body = body;
    }
    
    ~While() {
        delete this->cond;
        delete this->body;
    }
    
    void accept(StmtVisitor< void >* ev) {
        ev->visitWhileStmt(this);
    }
    
    char type() const {
        return 'W';
    }

    Expr* cond;
    Stmt* body;
};

class Function : public Stmt {
public:
    Function(Token fnName, vector < Token > params, Block* body) {
        this->fnName = fnName;
        this->params = params;
        this->body = body;
    }
    
    ~Function() {
        delete this->body;
    }
    
    void accept(StmtVisitor< void >* ev) {
        ev->visitFunctionStmt(this);
    }
    
    char type() const {
        return 'F';
    }

    Token fnName;
    vector < Token > params;
    Block* body;
};

class Return : public Stmt {
public:
    Return(Token ret, Expr* value) {
        this->ret = ret;
        this->value = value;
    }
    
    ~Return() {
        delete this->value;
    }
    
    void accept(StmtVisitor< void >* ev) {
        ev->visitReturnStmt(this);
    }
    
    char type() const {
        return 'R';
    }

    Token ret;
    Expr* value;
};
