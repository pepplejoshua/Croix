//
// Expr.h
// Croix
//
// Generated by Joshua Pepple on 2021-12-05.
//

#ifndef Expr_h
#define Expr_h

#include <iostream>
#include <string>
#include "../Token.h"

using namespace std;

template <typename RValue>
class Visitor;

class Expr {
public:
    template <typename RValue>
    RValue accept(Visitor< RValue >* visitor);
    
    virtual string type() const = 0;

    string terminator = '\0';
};

class Program : public Expr {
    public:
    Program(Expr* body) {
        this->body = body;
    }
    
    template <typename RValue>
    RValue accept(Visitor< RValue >* visitor) {
        return visitor->visitProgramExpr(this);
    }

    string type() const {
        return "Program";
    }

    Expr* body;
};

class Binary : public Expr {
public:
    Binary(Expr* left, Token op, Expr* right) {
        this->left = left;
        this->op = op;
        this->right = right;
    }
    
    template <typename RValue>
    RValue accept(Visitor<RValue>* visitor) {
        return visitor->visitBinaryExpr(this);
    }

    string type() const {
        return "Binary";
    }
    
    Expr* left;
    Token op;
    Expr* right;
};

class Unary : public Expr {
public:
    Unary(Token op, Expr* right) {
        this->op = op;
        this->right = right;
    }
    
    template <typename RValue>
    RValue accept(Visitor<RValue>* visitor) {
        return visitor->visitUnaryExpr(this);
    }

    string type() const {
        return "Unary";
    }

    Token op;
    Expr* right;
};

class Grouping : public Expr {
public:
    Grouping(Expr* expr) {
        this->expr = expr;
    }
    
    template <typename RValue>
    RValue accept(Visitor<RValue>* visitor) {
        return visitor->visitGroupingExpr(this);
    }

    string type() const {
        return "Grouped";
    }

    Expr* expr;
};

class Boolean : public Expr {
public:
    Boolean(bool value) {
        this->value = value;
    }
    
    template <typename RValue>
    RValue accept(Visitor<RValue>* visitor) {
        return visitor->visitBooleanExpr(this);
    }

    string type() const {
        return "Boolean";
    }

    bool value;
};

class Number : public Expr {
public:
    Number(double value) {
        this->value = value;
    }
    
    template <typename RValue>
    RValue accept(Visitor<RValue>* visitor) {
        return visitor->visitNumberExpr(this);
    }

    string type() const {
        return "Number";
    }

    double value;
};

class String : public Expr {
public:
    String(string value) {
        this->value = value;
    }
    
    template <typename RValue>
    RValue accept(Visitor<RValue>* visitor) {
        return visitor->visitStringExpr(this);
    }

    string type() const {
        return "String";
    }

    string value;
};

template <typename RValue>
class Visitor {
public:
    virtual RValue visitProgramExpr(Program* expr) = 0;
    virtual RValue visitBinaryExpr(Binary* expr) = 0;
    virtual RValue visitUnaryExpr(Unary* expr) = 0;
    virtual RValue visitGroupingExpr(Grouping* expr) = 0;
    virtual RValue visitBooleanExpr(Boolean* expr) = 0;
    virtual RValue visitNumberExpr(Number* expr) = 0;
    virtual RValue visitStringExpr(String* expr) = 0;

    RValue store;
};

#endif /* Expr_h */